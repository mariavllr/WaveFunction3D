// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

/*
|-------------------------------------------------------------------------------|
| Arrays in HLSL must have an explicit lenght given at their declaration        |
| so the maximum number of neighbours is defined as a constant.                 |
|-------------------------------------------------------------------------------|
*/
#define MAX_NEIGHBOURS 44

struct Cell3DStruct
{
    uint colapsed;
    // Number of tiles that can be placed in the cell
    // (array lenghts are fixed we can't use .lenght)
    uint entropy;
    /* Possible tiles
    |-------------------------------------------------------------------------------|
    | The possible tiles are stored in a uint array, each uint containing the index |
    | of a tile in the tileObjects array.                                           |
    |-------------------------------------------------------------------------------|
    */
    int tileOptions[MAX_NEIGHBOURS];
};

struct Tile3DStruct
{
    int tyleType; // Hascode of the tile
    int probability;
    float3 rotation;

    // Neighbours (these are the indexes of the tiles in the tileObjects array)
    int upNeighbours[MAX_NEIGHBOURS];
    int rightNeighbours[MAX_NEIGHBOURS];
    int downNeighbours[MAX_NEIGHBOURS];
    int leftNeighbours[MAX_NEIGHBOURS];
    int aboveNeighbours[MAX_NEIGHBOURS];
    int belowNeighbours[MAX_NEIGHBOURS];

    // Excluded neighbours
    int excludedNeighboursUp[MAX_NEIGHBOURS];       // Hashcodes of the tiles
    int excludedNeighboursRight[MAX_NEIGHBOURS];    // Hashcodes of the tiles
    int excludedNeighboursDown[MAX_NEIGHBOURS];     // Hashcodes of the tiles
    int excludedNeighboursLeft[MAX_NEIGHBOURS];     // Hashcodes of the tiles

    /* Sockets
    |-------------------------------------------------------------------------------|
    | HLSL doesn't support nested structs so the sockets are represented as arrays. |
    | [0] = Up, [1] = Right, [2] = Left, [3] = Down, [4] = Above, [5] = Below       |
    |-------------------------------------------------------------------------------|
    | socketNames contains the names of the sockets in the form of ints that        |
    | represent the enums in the C# code with the following correspondence:         |
    | GRASS = 0, PATH = 1, WATER = 3, EMPTY = 4, WALL_LATERAL = 5, WALL_TOP = 6,    |
    | WALL_CORNER_EXT = 7, WALL_CORNER_INT = 8, BORDER = 9, GRASS_BORDER = 10       |
    | SOLID = 11                                                                    |
    |-------------------------------------------------------------------------------|
    | To avoid memory alignment issues, all the bools are stored in a uint array,   |
    | each uint contaiining the bools for a socket.                                 |
    | they can be accessed as follows:                                              |
    | horizontalFace = ((socketFlags[x] & 0x01) != 0)                               |
    | isSymmetric = ((socketFlags[x] & 0x02) != 0)                                  |
    | isFlipped = ((socketFlags[x] & 0x04) != 0)                                    |
    | isVerticalFace = ((socketFlags[x] & 0x08) != 0)                               |
    | rotationallyInvariant = ((socketFlags[x] & 0x10) != 0)                        |
    |-------------------------------------------------------------------------------|
    | rotationIndexes contains the indexes of the rotations of the sockets.         |
    |-------------------------------------------------------------------------------|
    */
    uint socketsNames[6];
    uint socketFlags[6];
    uint rotatioIndexes[6];
};

// Values from de C# code
uint dimensionsX, dimensionsY, dimensionsZ;
uint iterations;
uint floorTile;
uint emptyTile;

// Save the cell with less entropy
uint minEntropy;
uint minEntropyIndex;

//Copy of the grid
RWStructuredBuffer<Cell3DStruct> modifiableGrid;

// Buffers
StructuredBuffer<Cell3DStruct> gridComponents;
StructuredBuffer<Tile3DStruct> tileObjects;
RWStructuredBuffer<Cell3DStruct> output;

// We need arrays of fixed lenght in HLSL, so -1 will be our null value
void ClearArray(int array[MAX_NEIGHBOURS])
{
    for (uint i = 0; i < MAX_NEIGHBOURS; i++)
    {
        array[i] = -1;
    }
}

// We need to have a modifiable copy of the grid so we copy it to another buffer
void CreateModifiableGrid(uint2 initialIndex)
{
    for(int i = 0; i < dimensionsX * dimensionsY * dimensionsZ; i++)
    {
        modifiableGrid[i] = gridComponents[i];
    }
}

void CreateSolidFloor(uint2 initialIndex)
{
    uint y = 0;
    for (uint z = initialIndex.y; z < dimensionsZ; z++)
    {
        for (uint x = initialIndex.x; x < dimensionsX; x++)
        {
            uint index = x + (z * dimensionsX) + (y * dimensionsX * dimensionsZ);
            output[index] = modifiableGrid[index];
            output[index].colapsed = (uint) 1;
            ClearArray(output[index].tileOptions);
            output[index].tileOptions[0] = floorTile;
            iterations++;
        }
    }
}

void CreateSolidCeling(uint2 initialIndex)
{
    int y = dimensionsY-1;
    for (uint z = 0; z < dimensionsZ; z++)
    {
        for (uint x = 0; x < dimensionsX; x++)
        {
            uint index = x + (z * dimensionsX) + (y * dimensionsX * dimensionsZ);
            output[index] = modifiableGrid[index];
            output[index].colapsed = (uint) 1;
            ClearArray(output[index].tileOptions);
            output[index].tileOptions[0] = emptyTile;
            iterations++;
        }
    }
}

bool ArrayContains(int list[MAX_NEIGHBOURS], int value)
{
    for (int i = 0; i < MAX_NEIGHBOURS; i++)
    {
        if(list[i] == -1) return false;
        if (list[i] == value) return true;
    }
    return false;
}

void CheckNeighbours(uint x, uint y, uint z)
{
    minEntropy = MAX_NEIGHBOURS + 1;
    minEntropyIndex = 0;

    uint up, down, left, right, above, below;
    uint index = x + (z * dimensionsX) + (y * dimensionsX * dimensionsZ);
    right = (x + 1) + (z * dimensionsX) + (y * dimensionsX * dimensionsZ);
    left = (x - 1) + (z * dimensionsX) + (y * dimensionsX * dimensionsZ);
    up = x + ((z + 1) * dimensionsX) + (y * dimensionsX * dimensionsZ);
    down = x + ((z - 1) * dimensionsX) + (y * dimensionsX * dimensionsZ);
    above = x + (z * dimensionsX) + ((y + 1) * dimensionsX * dimensionsZ);
    below = x + (z * dimensionsX) + ((y - 1) * dimensionsX * dimensionsZ);

    if(modifiableGrid[index].colapsed == 1) return;

    /* Adaptation of the get neighbours method in the C# code
    |-------------------------------------------------------------------------------|
    | In the original code, we use a method that concatenates all the possible      |
    | neighbours in each of the possible tiles in the position of each neighbour    |
    | that is used to check the intersection between that list and the list of      |
    | overall tile options.                                                         |
    |-------------------------------------------------------------------------------|
    | In the HLSL code, to avoid lists and its manipulations, we will go through    |
    | all the possible neighbours and check if they are in the arrays of neighbours |
    | of all the possible tiles of each neighbour.                                  |
    |-------------------------------------------------------------------------------|
    */
    int optionIndex = 0;
    int validOptionsIndex = 0;
    int validOptions[MAX_NEIGHBOURS];
    ClearArray(validOptions);
    while (optionIndex < MAX_NEIGHBOURS && modifiableGrid[index].tileOptions[optionIndex] != -1)
    {
        bool isNeighbour = true;
        // Checks the down cell
        if(z > 0)
        {
            for(int i = 0; i < MAX_NEIGHBOURS; i++)
            {
                // Check if we have reached the end of the array of tile options
                if(modifiableGrid[down].tileOptions[i] == -1)
                {
                    // If we get to the end, it means that the option is not
                    // in the lists of possible neighbours of all the possible neighbour
                    // tiles, therefore it is not valid so we skip it
                    if(optionIndex < MAX_NEIGHBOURS) optionIndex++;
                    break;
                }

                isNeighbour = ArrayContains(tileObjects[modifiableGrid[down].tileOptions[i]].upNeighbours, modifiableGrid[index].tileOptions[optionIndex]);
                if(!isNeighbour) break;
            }
        }
        // Checks the right cell
        if(isNeighbour && x < dimensionsX - 1)
        {
            for(int i = 0; i < MAX_NEIGHBOURS; i++)
            {
                // Check if we have reached the end of the array of tile options
                if(modifiableGrid[right].tileOptions[i] == -1)
                {
                    // If we get to the end, it means that the option is not
                    // in the lists of possible neighbours of all the possible neighbour
                    // tiles, therefore it is not valid so we skip it
                    if(optionIndex < MAX_NEIGHBOURS) optionIndex++;
                    break;
                }

                isNeighbour = ArrayContains(tileObjects[modifiableGrid[right].tileOptions[i]].leftNeighbours, modifiableGrid[index].tileOptions[optionIndex]);
                if(!isNeighbour) break;
            }
        }
        // Checks the up cell
        if(isNeighbour && z < dimensionsZ - 1)
        {
            for(int i = 0; i < MAX_NEIGHBOURS; i++)
            {
                // Check if we have reached the end of the array of tile options
                if(modifiableGrid[up].tileOptions[i] == -1)
                {
                    // If we get to the end, it means that the option is not
                    // in the lists of possible neighbours of all the possible neighbour
                    // tiles, therefore it is not valid so we skip it
                    if(optionIndex < MAX_NEIGHBOURS) optionIndex++;
                    break;
                }

                isNeighbour = ArrayContains(tileObjects[modifiableGrid[up].tileOptions[i]].downNeighbours, modifiableGrid[index].tileOptions[optionIndex]);
                if(!isNeighbour) break;
            }
        }
        // Checks the left cell
        if(isNeighbour && x > 0)
        {
            for(int i = 0; i < MAX_NEIGHBOURS; i++)
            {
                // Check if we have reached the end of the array of tile options
                if(modifiableGrid[left].tileOptions[i] == -1)
                {
                    // If we get to the end, it means that the option is not
                    // in the lists of possible neighbours of all the possible neighbour
                    // tiles, therefore it is not valid so we skip it
                    if(optionIndex < MAX_NEIGHBOURS) optionIndex++;
                    break;
                }

                isNeighbour = ArrayContains(tileObjects[modifiableGrid[left].tileOptions[i]].rightNeighbours, modifiableGrid[index].tileOptions[optionIndex]);
                if(!isNeighbour) break;
            }
        }
        // Checks the below cell
        if(isNeighbour && y > 0)
        {
            for(int i = 0; i < MAX_NEIGHBOURS; i++)
            {
                // Check if we have reached the end of the array of tile options
                if(modifiableGrid[below].tileOptions[i] == -1)
                {
                    // If we get to the end, it means that the option is not
                    // in the lists of possible neighbours of all the possible neighbour
                    // tiles, therefore it is not valid so we skip it
                    if(optionIndex < MAX_NEIGHBOURS) optionIndex++;
                    break;
                }

                isNeighbour = ArrayContains(tileObjects[modifiableGrid[below].tileOptions[i]].aboveNeighbours, modifiableGrid[index].tileOptions[optionIndex]);
                if(!isNeighbour) break;
            }
        }
        // Checks the above cell
        if(isNeighbour && y < dimensionsY - 1)
        {
            for(int i = 0; i < MAX_NEIGHBOURS; i++)
            {
                // Check if we have reached the end of the array of tile options
                if(modifiableGrid[above].tileOptions[i] == -1)
                {
                    // If we get to the end, it means that the option is not
                    // in the lists of possible neighbours of all the possible neighbour
                    // tiles, therefore it is not valid so we skip it
                    if(optionIndex < MAX_NEIGHBOURS) optionIndex++;
                    break;
                }

                isNeighbour = ArrayContains(tileObjects[modifiableGrid[above].tileOptions[i]].belowNeighbours, modifiableGrid[index].tileOptions[optionIndex]);
                if(!isNeighbour) break;
            }
        }
        if(isNeighbour)
        {
            validOptions[validOptionsIndex] = optionIndex;
            if(validOptionsIndex < MAX_NEIGHBOURS) validOptionsIndex++;
        }
        if(optionIndex < MAX_NEIGHBOURS) optionIndex++;
    }

    // We assign the new options to the cell
    modifiableGrid[index].tileOptions = validOptions;
    modifiableGrid[index].entropy = validOptionsIndex;
    if(validOptionsIndex < minEntropy)
    {
        minEntropy = validOptionsIndex;
        minEntropyIndex = index;
    }
}

bool CollapseCell(int cellToCollapseIndex)
{
    // Collapse the cell
    modifiableGrid[cellToCollapseIndex].colapsed = 1;

    // Get the tile with more probability
    int maxProbability = 0;
    int maxProbabilityIndex = -1;
    for(int i = 0; i < MAX_NEIGHBOURS; i++)
    {
        if(modifiableGrid[cellToCollapseIndex].tileOptions[i] == -1) break;
        if(tileObjects[modifiableGrid[cellToCollapseIndex].tileOptions[i]].probability >= maxProbability)
        {
            maxProbability = tileObjects[modifiableGrid[cellToCollapseIndex].tileOptions[i]].probability;
            maxProbabilityIndex = i;
        }
    }

    // Check for incopatibility
    if (maxProbabilityIndex == -1)
    {
        return false;
    }

    int temp = modifiableGrid[cellToCollapseIndex].tileOptions[maxProbabilityIndex];
    ClearArray(modifiableGrid[cellToCollapseIndex].tileOptions);
    modifiableGrid[cellToCollapseIndex].tileOptions[0] = temp;
    modifiableGrid[cellToCollapseIndex].entropy = 1;
    output[cellToCollapseIndex] = modifiableGrid[cellToCollapseIndex];
    return true;
}

void UpdateGeneration(uint2 initialIndex)
{
    while (iterations <= dimensionsX * dimensionsZ * dimensionsY)
    {
        for (uint y = 0; y < dimensionsY; y++)
        {
            for (uint z = initialIndex.y; z < dimensionsZ; z++)
            {
                for (uint x = initialIndex.x; x < dimensionsX; x++)
                {
                    CheckNeighbours(x, y, z);
                }
            }
        }
        iterations++;

        // If there's an incompatibility, we restart everything
        if(CollapseCell(minEntropyIndex)) continue;
        else
        {
            iterations = 0;
            CreateModifiableGrid(initialIndex);
            CreateSolidFloor(initialIndex);
            CreateSolidCeling(initialIndex);
        }
    }
}

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint2 initialIndex = id.xy;
    CreateSolidFloor(initialIndex);
    CreateSolidCeling(initialIndex);
    UpdateGeneration(initialIndex);
}